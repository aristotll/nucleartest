`>>>>>>>>>>>>>>>>>>>>>

在 a 文件夹下有 3 个 c++ 文件：math.h , main.cc, foo.cc，math.h 里定义了一个 add 函数，然后 main.cc 和 foo.cc 都 #include "math.h"，执行 g++ main.cc foo.cc math.h  后报错 duplicate symbol '__Z3addii' in:，这是为什么？

`>>>>>>>>>>>>>>>>>>>>>



<<<<<<<<<<<<<<<<<<<<<<

这是因为在执行 g++ main.cc foo.cc math.h 时，你把 math.h 文件也当作了源文件来编译，而不是头文件。你在 main.cc 和 foo.cc 中都包含了 "math.h"，那么 add 函数就在两个文件中都被编译进去了，因此在链接阶段就会出现重复符号的错误。

解决方法是只将 math.h 文件作为头文件，源文件分别编译，最后再链接。例如：

g++ -c main.cc
g++ -c foo.cc
g++ main.o foo.o

这样，在链接阶段 add 函数的定义就只会在一个文件中出现，避免了重复符号的错误。

<<<<<<<<<<<<<<<<<<<<<<



`>>>>>>>>>>>>>>>>>>>>>

g++ -c 是什么意思

`>>>>>>>>>>>>>>>>>>>>>



<<<<<<<<<<<<<<<<<<<<<<

`g++ -c` 是在编译 C++ 程序时使用的一个选项，它表示只编译源代码文件，不进行链接。通常我们会先使用 `g++ -c` 对所有源文件分别进行编译，最后再使用 `g++` 对所有生成的目标文件进行链接。

这个选项对大型项目来说很有用，因为它可以让我们在修改源代码时只编译被修改的文件，然后再与其他目标文件链接，从而减少编译时间。

<<<<<<<<<<<<<<<<<<<<<<



`>>>>>>>>>>>>>>>>>>>>>

duplicate symbol '__Z3addii' in 为什么报错信息这么古怪？这个重复定义的函数叫 add，为什么报错提示的是 Z3addii？

`>>>>>>>>>>>>>>>>>>>>>



<<<<<<<<<<<<<<<<<<<<<<

这是因为 `__Z3addii` 是 add 函数的符号名，而不是函数名。

在 C++ 中，函数名通常是一个字符串，但是编译器并不直接使用这个字符串，而是使用一个符号名来代替它。这个符号名是一个与函数名相关的数字，用于在编译后的代码中对函数进行引用。

在 Linux 系统上，一般使用 C++ 的默认符号命名约定是 C++ 运行时符号约定，即 "C++ ABI"（Application Binary Interface）。根据 C++ ABI 规定，函数符号名的格式通常是 __Zn，其中 n 是一个数字，表示函数名称。

因此，在报错信息中出现的 `__Z3addii` 其实是 add 函数的符号名，而不是函数名。编译器把函数名编译成了符号名，以便在链接阶段进行引用，因此在报错信息中出现了符号名而不是函数名。

<<<<<<<<<<<<<<<<<<<<<<



`>>>>>>>>>>>>>>>>>>>>>

那我如何分辨是哪个函数重复定义了呢，如果在一个大型项目下

`>>>>>>>>>>>>>>>>>>>>>



<<<<<<<<<<<<<<<<<<<<<<

如果您在大型项目中遇到了重复定义的问题，您可以使用一些工具来帮助您解决这个问题。

一种方法是使用 c++filt 工具。c++filt 可以将符号名转换成函数名，因此您可以使用 c++filt 来分析编译器报错信息。例如：

```sh
$ c++filt __Z3addii
add(int, int)
```

还有一种方法是使用 nm 工具。nm 可以列出一个可执行文件或目标文件的符号表。您可以使用 nm 来检查每个目标文件，以确定是哪个文件定义了重复的符号。例如：

```sh
$ nm main.o
0000000000000030 T __Z3addii

$ nm foo.o
0000000000000030 T __Z3addii
```

在这个例子中，两个目标文件都定义了符号 __Z3addii，因此这两个文件都会导致重复定义的问题。

通过使用这些工具，您可以快速确定重复定义的问题所在，从而解决问题。

<<<<<<<<<<<<<<<<<<<<<<
